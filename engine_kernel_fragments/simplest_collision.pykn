simplest_collision
4

        private int error, doubleError;
        private short scalarVectorX, scalarVectorY;
        private int absVectorX, absVectorY, loopLength;
        private bool tempLogic;
        __global struct voxel* prevVoxel, *currentVoxel;

        prevVoxel = thisVoxel;

        scalarVectorX = (thisVoxelCopy.forceVector.x > 0) ? 1 : -1;
        scalarVectorY = (thisVoxelCopy.forceVector.y > 0) ? 1 : -1;
        absVectorX = abs(thisVoxelCopy.forceVector.x);
        absVectorY = abs(thisVoxelCopy.forceVector.y);
        loopLength = (absVectorX > absVectorY) ? absVectorX : absVectorY;
        error = absVectorX - absVectorY;



        if (loopLength > 0){
            doubleError = error*2;

            tempLogic = doubleError > -absVectorY;
            error -= absVectorY * tempLogic;
            tempX += scalarVectorX * tempLogic;

            tempLogic = doubleError < absVectorX;
            error += absVectorX * tempLogic;
            tempY += scalarVectorY * tempLogic;

            if (tempX >= localConfig.simulationWidth || tempY >= localConfig.simulationHeight || tempX <= 0 || tempY <= 0){
                prevVoxel->substanceID = 0;
            } else {
                currentVoxel = &resources->worldMap->voxels[tempX + tempY * localConfig.simulationWidth];
                if (currentVoxel->substanceID > 0){
                    prevVoxel->forceVector.x = 0;
                    prevVoxel->forceVector.y = 0;
                } else {
                    prevVoxel->substanceID = 0;
                    prevVoxel = currentVoxel;

                    for (uint i = 1; i < loopLength; i++){
                        doubleError = error*2;

                        tempLogic = doubleError > -absVectorY;
                        error -= absVectorY * tempLogic;
                        tempX += scalarVectorX * tempLogic;

                        tempLogic = doubleError < absVectorX;
                        error += absVectorX * tempLogic;
                        tempY += scalarVectorY * tempLogic;

                        if (tempX >= localConfig.simulationWidth || tempY >= localConfig.simulationHeight || tempX <= 0 || tempY <= 0){
                            thisVoxelCopy.substanceID = 0;
                            break;
                        }
                        currentVoxel = &resources->worldMap->voxels[tempX + tempY * localConfig.simulationWidth];
                        if (currentVoxel->substanceID > 0){
                            prevVoxel->substanceID = thisVoxelCopy.substanceID; //redundant but more safe
//                             thisVoxelCopy.forceVector.x *= -0.5;
//                             thisVoxelCopy.forceVector.y *= -0.5;
//                             currentVoxel->forceVector.x -= thisVoxelCopy.forceVector.x;
//                             currentVoxel->forceVector.y -= thisVoxelCopy.forceVector.y;
                            thisVoxelCopy.forceVector.x = 0;
                            thisVoxelCopy.forceVector.y = 0;
                            break;
                        }
                        prevVoxel = currentVoxel;
                    }
                    prevVoxel->substanceID = thisVoxelCopy.substanceID;
                    prevVoxel->forceVector.y = thisVoxelCopy.forceVector.y;
                    prevVoxel->forceVector.x = thisVoxelCopy.forceVector.x;
                }
//                 prevVoxel = currentVoxel;
            }
        }



//         global_ID = IDX + IDY * localConfig.simulationWidth;
